# WorkBot æ ¸å¿ƒé€šè®¯ä¸é›†æˆæ–‡æ¡£

> **æ–‡æ¡£ç‰ˆæœ¬**ï¼šv4.0
> **æœ€åæ›´æ–°**ï¼š2026-02-06
> **é€‚ç”¨å¯¹è±¡**ï¼šå¼€å‘å·¥ç¨‹å¸ˆã€æ¶æ„å¸ˆã€é›†æˆå·¥ç¨‹å¸ˆ

---

## ğŸ“‹ ç›®å½•

1. [ç³»ç»Ÿè®¾è®¡æ€è·¯](#1-ç³»ç»Ÿè®¾è®¡æ€è·¯)
2. [ç³»ç»Ÿæ¶æ„æ€è·¯](#2-ç³»ç»Ÿæ¶æ„æ€è·¯)
3. [APPé€šè®¯åè®®](#3-appé€šè®¯åè®®)
4. [APPéªŒè¯æ–¹å¼](#4-appéªŒè¯æ–¹å¼)
5. [APPé€šè®¯ä»£ç ](#5-appé€šè®¯ä»£ç )
6. [ç¬¬ä¸‰æ–¹å¹³å°é€šè®¯åè®®](#6-ç¬¬ä¸‰æ–¹å¹³å°é€šè®¯åè®®)
7. [é€šè®¯åœ°å€](#7-é€šè®¯åœ°å€)

---

## 1. ç³»ç»Ÿè®¾è®¡æ€è·¯

### 1.1 æ ¸å¿ƒè®¾è®¡ç†å¿µ

WorkBot ç³»ç»Ÿçš„è®¾è®¡å›´ç»•ä»¥ä¸‹å‡ ä¸ªæ ¸å¿ƒåŸåˆ™å±•å¼€ï¼š

#### 1.1.1 è®¾å¤‡å”¯ä¸€ç»‘å®šåŸåˆ™

**è®¾è®¡ç›®æ ‡**ï¼šä¸€ä¸ªæ¿€æ´»ç åªèƒ½ç»‘å®šä¸€ä¸ªè®¾å¤‡ï¼Œé˜²æ­¢æ¿€æ´»ç è¢«æ»¥ç”¨ã€‚

**å®ç°æ–¹å¼**ï¼š
- ä½¿ç”¨è®¾å¤‡IDï¼ˆAndroid IDï¼‰+ è®¾å¤‡æŒ‡çº¹åŒé‡éªŒè¯
- æ¿€æ´»åè®°å½•è®¾å¤‡ä¿¡æ¯ï¼Œåç»­æ¿€æ´»æ—¶éªŒè¯è®¾å¤‡æ˜¯å¦åŒ¹é…
- æ”¯æŒåŒä¸€è®¾å¤‡é‡å¤æ¿€æ´»ï¼ˆå¸è½½é‡è£…ï¼‰

**ä¸šåŠ¡ä»·å€¼**ï¼š
- ä¿æŠ¤æ¿€æ´»ç èµ„äº§ï¼Œé˜²æ­¢åˆ†äº«å’Œç›—ç”¨
- ä¾¿äºè¿½è¸ªå’Œç®¡ç†è®¾å¤‡
- æé«˜å®‰å…¨æ€§

#### 1.1.2 å®æ—¶åŒå‘é€šè®¯åŸåˆ™

**è®¾è®¡ç›®æ ‡**ï¼šæœåŠ¡å™¨ä¸APPä¹‹é—´å®ç°ä½å»¶è¿Ÿã€é«˜å¯é çš„åŒå‘é€šè®¯ã€‚

**å®ç°æ–¹å¼**ï¼š
- ä½¿ç”¨ WebSocket ä½œä¸ºä¸»è¦é€šè®¯é€šé“
- HTTP ä½œä¸ºè¾…åŠ©é€šé“ï¼ˆæ¿€æ´»ã€å¿ƒè·³ç­‰ï¼‰
- å®ç°æ–­çº¿é‡è¿ã€æ¶ˆæ¯é˜Ÿåˆ—ã€å¤±è´¥é‡è¯•æœºåˆ¶

**ä¸šåŠ¡ä»·å€¼**ï¼š
- å®æ—¶æ¥æ”¶æ¶ˆæ¯å’Œä¸‹å‘æŒ‡ä»¤
- æå‡ç”¨æˆ·ä½“éªŒå’Œå“åº”é€Ÿåº¦
- æ”¯æŒå¤æ‚äº¤äº’åœºæ™¯

#### 1.1.3 WorkTool å…¼å®¹åŸåˆ™

**è®¾è®¡ç›®æ ‡**ï¼šå®Œå…¨å…¼å®¹ WorkTool å¹³å°çš„æ‰€æœ‰åŠŸèƒ½ã€‚

**å®ç°æ–¹å¼**ï¼š
- å®ç° WorkTool çš„ 16 ç§æ¶ˆæ¯ç±»å‹
- å…¼å®¹ WorkTool çš„ API æ¥å£
- æ”¯æŒ HTTP å›è°ƒå’Œ WebSocket ä»£ç†ä¸¤ç§é›†æˆæ–¹å¼

**ä¸šåŠ¡ä»·å€¼**ï¼š
- æ— ç¼è¿ç§»ç°æœ‰ WorkTool ç”¨æˆ·
- é™ä½è¿ç§»æˆæœ¬
- ä¿æŒåŠŸèƒ½å®Œæ•´æ€§

#### 1.1.4 ç¬¬ä¸‰æ–¹æ‰©å±•åŸåˆ™

**è®¾è®¡ç›®æ ‡**ï¼šæ”¯æŒç¬¬ä¸‰æ–¹ç³»ç»Ÿé€šè¿‡æ ‡å‡†åè®®é›†æˆã€‚

**å®ç°æ–¹å¼**ï¼š
- æä¾› RESTful API
- æä¾› WebSocket æ¥å£
- æä¾› HTTP å›è°ƒæœºåˆ¶

**ä¸šåŠ¡ä»·å€¼**ï¼š
- æ”¯æŒå®šåˆ¶åŒ–éœ€æ±‚
- æ‰©å±•ç”Ÿæ€ç³»ç»Ÿ
- å¢åŠ å•†ä¸šä»·å€¼

### 1.2 å…³é”®è®¾è®¡å†³ç­–

#### 1.2.1 ä¸ºä»€ä¹ˆä½¿ç”¨ WebSocket è€Œéè½®è¯¢ï¼Ÿ

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | å†³ç­– |
|-----|------|------|------|
| **HTTPè½®è¯¢** | å®ç°ç®€å• | å»¶è¿Ÿé«˜ã€æœåŠ¡å™¨å‹åŠ›å¤§ | âŒ ä¸é‡‡ç”¨ |
| **é•¿è¿æ¥** | å®æ—¶æ€§å¥½ | å ç”¨èµ„æº | âš ï¸ å¤‡é€‰ |
| **WebSocket** | å®æ—¶ã€é«˜æ•ˆã€åŒå‘ | éœ€è¦é¢å¤–ç»´æŠ¤ | âœ… é‡‡ç”¨ |

**å†³ç­–ä¾æ®**ï¼š
- WorkBot éœ€è¦å®æ—¶æ¥æ”¶æ¶ˆæ¯å’Œä¸‹å‘æŒ‡ä»¤
- æ¶ˆæ¯é¢‘ç‡è¾ƒé«˜ï¼Œè½®è¯¢ä¸ç°å®
- WebSocket åœ¨ç§»åŠ¨ç«¯è¡¨ç°è‰¯å¥½

#### 1.2.2 ä¸ºä»€ä¹ˆä½¿ç”¨ JWT è€Œé Sessionï¼Ÿ

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | å†³ç­– |
|-----|------|------|------|
| **Session** | æœåŠ¡ç«¯å¯æ§ | éœ€è¦å­˜å‚¨ã€è·¨åŸŸå›°éš¾ | âŒ ä¸é‡‡ç”¨ |
| **JWT** | æ— çŠ¶æ€ã€è·¨åŸŸå‹å¥½ | æ— æ³•æ’¤é”€ã€Tokenè¾ƒå¤§ | âœ… é‡‡ç”¨ |

**å†³ç­–ä¾æ®**ï¼š
- APP å’ŒæœåŠ¡ç«¯åˆ†ç¦»éƒ¨ç½²
- éœ€è¦æ”¯æŒå¤šä¸ªæœºå™¨äººå¹¶å‘è¿æ¥
- JWT æ›´é€‚åˆåˆ†å¸ƒå¼æ¶æ„

#### 1.2.3 ä¸ºä»€ä¹ˆä½¿ç”¨è®¾å¤‡æŒ‡çº¹ï¼Ÿ

**é—®é¢˜**ï¼šä»…å‡­è®¾å¤‡IDä¸è¶³ä»¥é˜²æ­¢ä¼ªé€ ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
- æ”¶é›†è®¾å¤‡ä¿¡æ¯ï¼ˆå‹å·ã€OSã€åˆ¶é€ å•†ç­‰ï¼‰
- ç”Ÿæˆè®¾å¤‡æŒ‡çº¹å“ˆå¸Œ
- æ¿€æ´»å’Œè¿æ¥æ—¶åŒé‡éªŒè¯

**å®‰å…¨æ€§æå‡**ï¼š
- é˜²æ­¢æ¨¡æ‹Ÿå™¨ä¼ªé€ 
- æé«˜ç ´è§£éš¾åº¦
- ä¾¿äºå¼‚å¸¸æ£€æµ‹

### 1.3 ä¸šåŠ¡æµç¨‹è®¾è®¡

#### 1.3.1 æ¿€æ´»æµç¨‹

```
ç”¨æˆ·è¾“å…¥æ¿€æ´»ç 
    â†“
APPæ”¶é›†è®¾å¤‡ä¿¡æ¯
    â†“
POST /api/robot-ids/verify (éªŒè¯æ¿€æ´»ç )
    â†“
éªŒè¯é€šè¿‡ï¼Ÿ
    â”œâ”€â†’ å¦ â†’ æç¤ºé”™è¯¯
    â””â”€â†’ æ˜¯ â†’ ç»§ç»­
        â†“
POST /api/robot-ids/activate (æ¿€æ´»è®¾å¤‡)
    â†“
æœåŠ¡å™¨åˆ›å»ºæœºå™¨äººå®ä¾‹
    â†“
ç”Ÿæˆ JWT Token
    â†“
è¿”å› robotId + token
    â†“
APP ä¿å­˜é…ç½®åˆ° SharedPreferences
    â†“
APP è¿æ¥ WebSocket
    â†“
è¿›å…¥å·¥ä½œæ¨¡å¼
```

#### 1.3.2 æ¶ˆæ¯å¤„ç†æµç¨‹

```
APP æ¥æ”¶åˆ°ä¼ä¸šå¾®ä¿¡æ¶ˆæ¯
    â†“
é€šè¿‡ WebSocket ä¸ŠæŠ¥æ¶ˆæ¯
    â†“
æœåŠ¡å™¨ä¿å­˜æ¶ˆæ¯åˆ°æ•°æ®åº“
    â†“
è§¦å‘ HTTP å›è°ƒ (å¦‚æœé…ç½®)
    â†“
ç¬¬ä¸‰æ–¹ç³»ç»Ÿæ¥æ”¶å¹¶å¤„ç†
    â†“
ç¬¬ä¸‰æ–¹ç³»ç»Ÿé€šè¿‡ WorkTool API å‘é€å›å¤
    â†“
æœåŠ¡å™¨é€šè¿‡ WebSocket ä¸‹å‘æŒ‡ä»¤
    â†“
APP æ‰§è¡Œå‘é€æ“ä½œ
    â†“
APP ä¸ŠæŠ¥æ‰§è¡Œç»“æœ
    â†“
æœåŠ¡å™¨è§¦å‘ç»“æœå›è°ƒ
```

---

## 2. ç³»ç»Ÿæ¶æ„æ€è·¯

### 2.1 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        WorkBot ç³»ç»Ÿæ¶æ„                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚  Android APP â”‚  â”‚  ç®¡ç†åå°    â”‚  â”‚  ç¬¬ä¸‰æ–¹ç³»ç»Ÿ  â”‚             â”‚
â”‚  â”‚  (å®¢æˆ·ç«¯)    â”‚  â”‚  (Web)       â”‚  â”‚  (WorkTool)  â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚         â”‚                  â”‚                  â”‚                     â”‚
â”‚         â”‚ WSS              â”‚ HTTPS            â”‚ HTTPS              â”‚
â”‚         â”‚ HTTPS            â”‚                 â”‚                    â”‚
â”‚         â–¼                  â–¼                  â–¼                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚                    WorkBot æœåŠ¡å™¨                          â”‚      â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚      â”‚
â”‚  â”‚  â”‚ APIæœåŠ¡  â”‚  â”‚ WebSocketâ”‚  â”‚ å›è°ƒæœåŠ¡  â”‚          â”‚      â”‚
â”‚  â”‚  â”‚ (5000)   â”‚  â”‚ (5001)   â”‚  â”‚          â”‚          â”‚      â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚      â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚      â”‚
â”‚  â”‚  â”‚ è®¤è¯æ¨¡å—  â”‚  â”‚ æƒé™æ¨¡å—  â”‚  â”‚ AIæ¨¡å—    â”‚          â”‚      â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                     â”‚                                         â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚         â–¼           â–¼           â–¼                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚  â”‚PostgreSQLâ”‚ â”‚  Redis   â”‚ â”‚å¯¹è±¡å­˜å‚¨  â”‚                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æŠ€æœ¯æ ˆé€‰æ‹©

#### 2.2.1 åç«¯æŠ€æœ¯æ ˆ

| æŠ€æœ¯ | ç‰ˆæœ¬ | ç”¨é€” | é€‰æ‹©ç†ç”± |
|-----|------|------|---------|
| **Next.js** | 16 | Webæ¡†æ¶ | å…¨æ ˆèƒ½åŠ›ã€API Routesã€SSR |
| **TypeScript** | 5 | ç¼–ç¨‹è¯­è¨€ | ç±»å‹å®‰å…¨ã€å¼€å‘æ•ˆç‡ |
| **PostgreSQL** | 16 | æ•°æ®åº“ | å…³ç³»å‹ã€äº‹åŠ¡æ”¯æŒ |
| **Drizzle ORM** | latest | ORM | è½»é‡ã€ç±»å‹å®‰å…¨ã€æ€§èƒ½å¥½ |
| **WebSocket** | wsåº“ | å®æ—¶é€šè®¯ | æˆç†Ÿã€æ€§èƒ½å¥½ |
| **JWT** | jose | è®¤è¯ | æ— çŠ¶æ€ã€è·¨åŸŸå‹å¥½ |

#### 2.2.2 å‰ç«¯æŠ€æœ¯æ ˆ

| æŠ€æœ¯ | ç‰ˆæœ¬ | ç”¨é€” | é€‰æ‹©ç†ç”± |
|-----|------|------|---------|
| **Next.js** | 16 | æ¡†æ¶ | SSRã€è·¯ç”±ã€APIé›†æˆ |
| **React** | 19 | UIåº“ | ç”Ÿæ€æˆç†Ÿã€æ€§èƒ½å¥½ |
| **shadcn/ui** | latest | ç»„ä»¶åº“ | ç¾è§‚ã€å¯å®šåˆ¶ |
| **Tailwind CSS** | 4 | æ ·å¼ | å¼€å‘æ•ˆç‡ã€ä¸€è‡´æ€§ |

### 2.3 æ ¸å¿ƒæ¨¡å—æ¶æ„

#### 2.3.1 è®¤è¯æˆæƒæ¨¡å—

**èŒè´£**ï¼šç”¨æˆ·è®¤è¯ã€æƒé™ç®¡ç†ã€Tokenç®¡ç†

**æ ¸å¿ƒç»„ä»¶**ï¼š
```
src/lib/auth/
â”œâ”€â”€ jwt.ts              # JWT Token ç”Ÿæˆå’ŒéªŒè¯
â”œâ”€â”€ middleware.ts       # è®¤è¯ä¸­é—´ä»¶
â”œâ”€â”€ password.ts         # å¯†ç åŠ å¯†å’ŒéªŒè¯
â””â”€â”€ user-service.ts     # ç”¨æˆ·æœåŠ¡
```

**æµç¨‹**ï¼š
```
ç”¨æˆ·ç™»å½•
  â†“
éªŒè¯ç”¨æˆ·åå’Œå¯†ç 
  â†“
ç”Ÿæˆ JWT Token (7å¤©)
  â†“
ç”Ÿæˆ Refresh Token (30å¤©)
  â†“
è¿”å› Token
  â†“
å®¢æˆ·ç«¯ä¿å­˜ Token
  â†“
æ¯æ¬¡è¯·æ±‚æºå¸¦ Bearer Token
  â†“
æœåŠ¡ç«¯éªŒè¯ Token
```

#### 2.3.2 æœºå™¨äººç®¡ç†æ¨¡å—

**èŒè´£**ï¼šæœºå™¨äººæ³¨å†Œã€çŠ¶æ€ç®¡ç†ã€ä¿¡æ¯æ›´æ–°

**æ ¸å¿ƒç»„ä»¶**ï¼š
```
src/lib/services/
â”œâ”€â”€ robot-service.ts    # æœºå™¨äººæœåŠ¡
â””â”€â”€ robot-status.ts     # çŠ¶æ€ç®¡ç†
```

**çŠ¶æ€æœº**ï¼š
```
æœªæ³¨å†Œ â†’ æ¿€æ´» â†’ åœ¨çº¿/ç¦»çº¿ â†’ åˆ é™¤
```

#### 2.3.3 WebSocketé€šè®¯æ¨¡å—

**èŒè´£**ï¼šè¿æ¥ç®¡ç†ã€æ¶ˆæ¯å¤„ç†ã€æŒ‡ä»¤ä¸‹å‘

**æ ¸å¿ƒç»„ä»¶**ï¼š
```
src/lib/websocket/
â”œâ”€â”€ server.ts           # WebSocket æœåŠ¡å™¨
â”œâ”€â”€ connection.ts       # è¿æ¥ç®¡ç†
â””â”€â”€ message-handler.ts  # æ¶ˆæ¯å¤„ç†
```

**æ¶æ„**ï¼š
```
WebSocket Server (5001)
  â”œâ”€ Connection Pool (Map<robotId, WebSocket>)
  â”œâ”€ Message Handler
  â”‚  â”œâ”€ Heartbeat Handler
  â”‚  â”œâ”€ Status Handler
  â”‚  â”œâ”€ Message Handler
  â”‚  â”œâ”€ Result Handler
  â”‚  â””â”€ Error Handler
  â””â”€ Command Queue
```

#### 2.3.4 ç¬¬ä¸‰æ–¹é›†æˆæ¨¡å—

**èŒè´£**ï¼šWorkToolå…¼å®¹ã€HTTPå›è°ƒã€æŒ‡ä»¤ä¸‹å‘

**æ ¸å¿ƒç»„ä»¶**ï¼š
```
src/lib/
â”œâ”€â”€ worktool/
â”‚  â”œâ”€â”€ client.ts        # WorkTool å®¢æˆ·ç«¯
â”‚  â””â”€â”€ message-types.ts # æ¶ˆæ¯ç±»å‹å®šä¹‰
â””â”€â”€ services/
   â””â”€â”€ integration.ts   # é›†æˆæœåŠ¡
```

**é›†æˆæ–¹å¼**ï¼š
```
HTTP å›è°ƒ:
  WorkBot â†’ ç¬¬ä¸‰æ–¹ç³»ç»Ÿ (POST)

WebSocket ä»£ç†:
  WorkBot â†â†’ ç¬¬ä¸‰æ–¹ç³»ç»Ÿ (WS)

WorkTool API:
  ç¬¬ä¸‰æ–¹ç³»ç»Ÿ â†’ WorkBot â†’ APP
```

### 2.4 æ•°æ®æµè½¬æ¶æ„

#### 2.4.1 æ¶ˆæ¯æµè½¬

```
APP æ¥æ”¶æ¶ˆæ¯
  â†“
WebSocket ä¸ŠæŠ¥
  â†“
API å±‚æ¥æ”¶
  â†“
æ¶ˆæ¯æœåŠ¡å¤„ç†
  â”œâ”€ ä¿å­˜åˆ°æ•°æ®åº“
  â”œâ”€ è§¦å‘ HTTP å›è°ƒ
  â””â”€ é€šçŸ¥ AI æ¨¡å—
  â†“
ç¬¬ä¸‰æ–¹ç³»ç»Ÿæ¥æ”¶
  â†“
ç¬¬ä¸‰æ–¹ç³»ç»Ÿå¤„ç†
  â†“
WorkTool API è°ƒç”¨
  â†“
WebSocket ä¸‹å‘æŒ‡ä»¤
  â†“
APP æ‰§è¡ŒæŒ‡ä»¤
  â†“
WebSocket ä¸ŠæŠ¥ç»“æœ
  â†“
ç»“æœå›è°ƒ
```

#### 2.4.2 AIæ™ºèƒ½å›å¤æµè½¬

```
APP æ¥æ”¶æ¶ˆæ¯
  â†“
WebSocket ä¸ŠæŠ¥
  â†“
æ¶ˆæ¯æœåŠ¡å¤„ç†
  â†“
æ£€æŸ¥ AI é…ç½®
  â†“
åŠ è½½å¯¹è¯å†å²
  â†“
è°ƒç”¨ AI æ¨¡å‹
  â†“
ç”Ÿæˆå›å¤
  â†“
ä¿å­˜å¯¹è¯å†å²
  â†“
WebSocket ä¸‹å‘æŒ‡ä»¤
  â†“
APP æ‰§è¡ŒæŒ‡ä»¤
  â†“
WebSocket ä¸ŠæŠ¥ç»“æœ
```

---

## 3. APPé€šè®¯åè®®

### 3.1 é€šè®¯æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     APP é€šè®¯æ¶æ„                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚   APP                         Server                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚   â”‚ HTTP    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  API    â”‚                     â”‚
â”‚   â”‚ Client  â”‚    HTTPS        â”‚ Server  â”‚                     â”‚
â”‚   â”‚ (5000)  â”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚                            â”‚
â”‚       â”‚                           â”‚                            â”‚
â”‚       â”‚                           â–¼                            â”‚
â”‚   â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚   â”‚WebSocketâ”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚WebSocketâ”‚                        â”‚
â”‚   â”‚ Client  â”‚    WSS        â”‚ Server  â”‚                        â”‚
â”‚   â”‚ (5001)  â”‚              â”‚ (5001)  â”‚                        â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚       â”‚                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”                                                â”‚
â”‚   â”‚ SharedPreferences                                         â”‚
â”‚   â”‚ (robotId + token)                                       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 é€šè®¯æ–¹å¼å¯¹æ¯”

| é€šè®¯æ–¹å¼ | åè®® | ç«¯å£ | ç”¨é€” | ä¼˜å…ˆçº§ |
|---------|------|------|------|--------|
| **HTTP POST** | HTTPS | 5000 | æ¿€æ´»ã€å¿ƒè·³ã€ç»“æœä¸ŠæŠ¥ | ä¸­ |
| **WebSocket** | WSS | 5001 | åŒå‘å®æ—¶é€šè®¯ | é«˜ |

### 3.3 HTTP æ¥å£

#### 3.3.1 éªŒè¯æ¿€æ´»ç 

**æ¥å£**ï¼š`POST /api/robot-ids/verify`

**è¯·æ±‚**ï¼š
```json
{
  "code": "3CQ4Z9LE",
  "deviceId": "device-001"
}
```

**å“åº”**ï¼š
```json
{
  "success": true,
  "code": 0,
  "data": {
    "valid": true,
    "robotId": "RBml9n7nikHIMZU0",
    "status": "unused",
    "canActivate": true
  }
}
```

#### 3.3.2 æ¿€æ´»æœºå™¨äºº

**æ¥å£**ï¼š`POST /api/robot-ids/activate`

**è¯·æ±‚**ï¼š
```json
{
  "code": "3CQ4Z9LE",
  "deviceInfo": {
    "deviceId": "device-001",
    "model": "Samsung Galaxy S21",
    "os": "Android",
    "osVersion": "12",
    "manufacturer": "Samsung",
    "network": "4G",
    "appVersion": "1.0.0",
    "totalMemory": 8192,
    "screenResolution": "1080x2400"
  }
}
```

**å“åº”**ï¼š
```json
{
  "success": true,
  "code": 0,
  "data": {
    "robotId": "RBml9n7nikHIMZU0",
    "robotUuid": "uuid-xxx",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "refresh-token-xxx",
    "expiresAt": "2026-02-13T10:00:00Z"
  }
}
```

#### 3.3.3 å‘é€å¿ƒè·³

**æ¥å£**ï¼š`POST /api/heartbeat`

**è¯·æ±‚å¤´**ï¼š
```http
Authorization: Bearer {token}
```

**è¯·æ±‚**ï¼š
```json
{
  "timestamp": 1770341503000,
  "memoryUsage": 1024,
  "cpuUsage": 50,
  "batteryLevel": 80,
  "networkType": "wifi"
}
```

**å“åº”**ï¼š
```json
{
  "success": true,
  "code": 0,
  "data": {
    "serverTime": "2026-02-06T10:05:03.000Z"
  }
}
```

#### 3.3.4 ä¸ŠæŠ¥ç»“æœ

**æ¥å£**ï¼š`POST /api/result`

**è¯·æ±‚å¤´**ï¼š
```http
Authorization: Bearer {token}
```

**è¯·æ±‚**ï¼š
```json
{
  "commandId": "cmd-001",
  "status": "success",
  "result": {
    "message": "æ‰§è¡ŒæˆåŠŸ",
    "messageId": "msg-002"
  }
}
```

**å“åº”**ï¼š
```json
{
  "success": true,
  "code": 0,
  "data": {
    "commandId": "cmd-001",
    "status": "success",
    "completedAt": "2026-02-06T10:05:00.000Z"
  }
}
```

### 3.4 WebSocket æ¶ˆæ¯åè®®

#### 3.4.1 è¿æ¥

**åœ°å€**ï¼š`wss://your-server.com/ws/connect?token={token}`

**è¿æ¥æˆåŠŸ**ï¼š
```json
{
  "type": "connected",
  "data": {
    "robotId": "RBml9n7nikHIMZU0",
    "timestamp": 1770341503000
  }
}
```

#### 3.4.2 APP â†’ Server æ¶ˆæ¯

**1. å¿ƒè·³æ¶ˆæ¯**

```json
{
  "type": "heartbeat",
  "data": {
    "timestamp": 1770341503000,
    "memoryUsage": 1024,
    "batteryLevel": 80,
    "networkType": "wifi"
  },
  "timestamp": 1770341503000,
  "messageId": "hb-001"
}
```

**2. æ¶ˆæ¯ä¸ŠæŠ¥**

```json
{
  "type": "message",
  "data": {
    "senderId": "wxid-xxx",
    "senderName": "å¼ ä¸‰",
    "messageType": "text",
    "content": "ä½ å¥½ï¼Œåœ¨å—ï¼Ÿ",
    "chatType": "single",
    "timestamp": 1770341503000
  },
  "timestamp": 1770341503000,
  "messageId": "msg-001"
}
```

**3. ç»“æœä¸ŠæŠ¥**

```json
{
  "type": "result",
  "data": {
    "commandId": "cmd-001",
    "status": "success",
    "result": {
      "messageId": "msg-002"
    }
  },
  "timestamp": 1770341505000,
  "messageId": "res-001"
}
```

**4. é”™è¯¯ä¸ŠæŠ¥**

```json
{
  "type": "error",
  "data": {
    "errorCode": "E001",
    "errorMessage": "å‘é€å¤±è´¥ï¼šç½‘ç»œé”™è¯¯",
    "timestamp": 1770341506000
  },
  "timestamp": 1770341506000,
  "messageId": "err-001"
}
```

#### 3.4.3 Server â†’ APP æ¶ˆæ¯

**1. æŒ‡ä»¤ä¸‹å‘**

```json
{
  "type": "command",
  "data": {
    "commandId": "cmd-001",
    "commandType": "send_message",
    "params": {
      "target": "å¼ ä¸‰",
      "content": "ä½ å¥½ï¼",
      "messageType": "text"
    },
    "priority": 0
  },
  "timestamp": 1770341504000,
  "messageId": "cmd-001"
}
```

**2. é…ç½®æ¨é€**

```json
{
  "type": "config",
  "data": {
    "configType": "risk_control",
    "config": {
      "enabled": true,
      "randomDelayMin": 1000,
      "randomDelayMax": 3000
    },
    "version": 1
  },
  "timestamp": 1770341504000,
  "messageId": "cfg-001"
}
```

**3. å¿ƒè·³å“åº”**

```json
{
  "type": "heartbeat_response",
  "data": {
    "timestamp": 1770341504000,
    "serverTime": "2026-02-06T10:05:04.000Z"
  },
  "timestamp": 1770341504000,
  "messageId": "hb-res-001"
}
```

### 3.5 æ¶ˆæ¯ç±»å‹æ±‡æ€»

| æ–¹å‘ | type | è¯´æ˜ | ä¼˜å…ˆçº§ |
|-----|------|------|--------|
| **APP â†’ Server** | heartbeat | å¿ƒè·³ | é«˜ |
| **APP â†’ Server** | message | æ¶ˆæ¯ä¸ŠæŠ¥ | é«˜ |
| **APP â†’ Server** | result | ç»“æœä¸ŠæŠ¥ | ä¸­ |
| **APP â†’ Server** | error | é”™è¯¯ä¸ŠæŠ¥ | é«˜ |
| **Server â†’ APP** | command | æŒ‡ä»¤ä¸‹å‘ | é«˜ |
| **Server â†’ APP** | config | é…ç½®æ¨é€ | ä½ |
| **Server â†’ APP** | heartbeat_response | å¿ƒè·³å“åº” | ä¸­ |

---

## 4. APPéªŒè¯æ–¹å¼

### 4.1 æ¿€æ´»ç éªŒè¯

#### 4.1.1 éªŒè¯æµç¨‹

```
ç”¨æˆ·è¾“å…¥æ¿€æ´»ç 
    â†“
APPæ”¶é›†è®¾å¤‡ä¿¡æ¯
    â†“
POST /api/robot-ids/verify
    â†“
æœåŠ¡å™¨æŸ¥è¯¢æ¿€æ´»ç 
    â†“
æ£€æŸ¥æ¿€æ´»ç çŠ¶æ€
    â”œâ”€ æœªä½¿ç”¨ â†’ è¿”å› valid=true
    â”œâ”€ å·²ä½¿ç”¨ä¸”ç»‘å®šåˆ°å½“å‰è®¾å¤‡ â†’ è¿”å› valid=true (å¯é‡æ–°æ¿€æ´»)
    â”œâ”€ å·²ä½¿ç”¨ä¸”ç»‘å®šåˆ°å…¶ä»–è®¾å¤‡ â†’ è¿”å› valid=false
    â””â”€ å·²è¿‡æœŸ â†’ è¿”å› valid=false
```

#### 4.1.2 éªŒè¯è§„åˆ™

| æ¿€æ´»ç çŠ¶æ€ | ç»‘å®šçŠ¶æ€ | å½“å‰è®¾å¤‡ | ç»“æœ |
|-----------|---------|---------|------|
| unused | unbound | ä»»æ„ | âœ… valid=true |
| used | bound | åŒ¹é… | âœ… valid=true (å¯é‡æ–°æ¿€æ´») |
| used | bound | ä¸åŒ¹é… | âŒ valid=false |
| expired | - | - | âŒ valid=false |

### 4.2 è®¾å¤‡ç»‘å®šéªŒè¯

#### 4.2.1 è®¾å¤‡æŒ‡çº¹

**è®¾å¤‡ä¿¡æ¯æ”¶é›†**ï¼š
```json
{
  "deviceId": "device-001",
  "model": "Samsung Galaxy S21",
  "os": "Android",
  "osVersion": "12",
  "manufacturer": "Samsung",
  "network": "4G",
  "appVersion": "1.0.0",
  "totalMemory": 8192,
  "screenResolution": "1080x2400"
}
```

**éªŒè¯é€»è¾‘**ï¼š
```typescript
function verifyDeviceFingerprint(
  stored: string,
  provided: DeviceInfo
): boolean {
  const storedFingerprint = JSON.parse(stored);
  
  // 1. æ£€æŸ¥è®¾å¤‡ID
  if (storedFingerprint.deviceId !== provided.deviceId) {
    return false;
  }
  
  // 2. æ£€æŸ¥è®¾å¤‡åŸºç¡€ä¿¡æ¯ï¼ˆå…è®¸éƒ¨åˆ†å˜åŒ–ï¼‰
  const deviceMatch =
    storedFingerprint.model === provided.model &&
    storedFingerprint.os === provided.os &&
    storedFingerprint.manufacturer === provided.manufacturer;
  
  return deviceMatch;
}
```

### 4.3 JWT Token éªŒè¯

#### 4.3.1 Token ç”Ÿæˆ

```typescript
import { SignJWT } from 'jose';

async function generateToken(
  robotId: string,
  expiresIn: string = '7d'
): Promise<string> {
  const secret = new TextEncoder().encode(process.env.JWT_SECRET);
  
  const token = await new SignJWT({
    robotId,
    type: 'robot',
  })
    .setProtectedHeader({ alg: 'HS256' })
    .setExpirationTime(expiresIn)
    .setIssuedAt()
    .sign(secret);
  
  return token;
}
```

#### 4.3.2 Token éªŒè¯

```typescript
import { jwtVerify } from 'jose';

async function verifyToken(token: string): Promise<JWTPayload | null> {
  try {
    const secret = new TextEncoder().encode(process.env.JWT_SECRET);
    const { payload } = await jwtVerify(token, secret);
    return payload as unknown as JWTPayload;
  } catch (error) {
    console.error('JWT verification failed:', error);
    return null;
  }
}
```

#### 4.3.3 Token ä½¿ç”¨åœºæ™¯

| åœºæ™¯ | ç”¨é€” | æœ‰æ•ˆæœŸ |
|-----|------|--------|
| **Access Token** | APIè¯·æ±‚ã€WebSocketè¿æ¥ | 7å¤© |
| **Refresh Token** | åˆ·æ–°Access Token | 30å¤© |

### 4.4 WebSocket è¿æ¥éªŒè¯

#### 4.4.1 è¿æ¥æ—¶éªŒè¯

```typescript
// WebSocket æœåŠ¡å™¨
wss.on('connection', async (ws: WebSocket, req: IncomingMessage) => {
  try {
    // 1. ä»URLè·å–token
    const url = new URL(req.url!, `http://${req.headers.host}`);
    const token = url.searchParams.get('token');
    
    if (!token) {
      ws.close(4001, 'Token required');
      return;
    }
    
    // 2. éªŒè¯token
    const payload = await verifyToken(token);
    
    if (!payload || !payload.robotId) {
      ws.close(4001, 'Invalid token');
      return;
    }
    
    // 3. è·å–æœºå™¨äººä¿¡æ¯
    const robot = await getRobotById(payload.robotId);
    
    if (!robot) {
      ws.close(4002, 'Robot not found');
      return;
    }
    
    // 4. ä¿å­˜è¿æ¥
    connections.set(robot.id, ws);
    
    // 5. æ›´æ–°çŠ¶æ€
    await updateRobotStatus(robot.id, 'online');
    
  } catch (error) {
    console.error('Connection error:', error);
    ws.close(4000, 'Connection error');
  }
});
```

#### 4.4.2 å¿ƒè·³éªŒè¯

```typescript
// æœåŠ¡ç«¯å¿ƒè·³æ£€æµ‹
const heartbeatIntervals = new Map<string, NodeJS.Timeout>();

function startHeartbeatCheck(robotId: string, ws: WebSocket) {
  const interval = setInterval(() => {
    if (ws.readyState !== WebSocket.OPEN) {
      clearInterval(interval);
      connections.delete(robotId);
      updateRobotStatus(robotId, 'offline');
      return;
    }
    
    // å‘é€å¿ƒè·³è¯·æ±‚
    ws.send(JSON.stringify({
      type: 'heartbeat_request',
      timestamp: Date.now()
    }));
  }, 30000); // 30ç§’
  
  heartbeatIntervals.set(robotId, interval);
}
```

### 4.5 éªŒè¯å¤±è´¥å¤„ç†

#### 4.5.1 é”™è¯¯ç 

| é”™è¯¯ç  | è¯´æ˜ | å¤„ç†æ–¹å¼ |
|-------|------|---------|
| 4000 | è¿æ¥é”™è¯¯ | å…³é—­è¿æ¥ï¼Œç­‰å¾…é‡è¿ |
| 4001 | Tokenæ— æ•ˆ | æç¤ºç”¨æˆ·é‡æ–°æ¿€æ´» |
| 4002 | æœºå™¨äººä¸å­˜åœ¨ | æç¤ºç”¨æˆ·é‡æ–°æ¿€æ´» |
| 4003 | è®¾å¤‡ä¸åŒ¹é… | æç¤ºç”¨æˆ·ä½¿ç”¨æ­£ç¡®è®¾å¤‡ |

#### 4.5.2 é‡è¿ç­–ç•¥

```kotlin
// æŒ‡æ•°é€€é¿ç­–ç•¥
val RECONNECT_DELAYS = listOf(1000, 2000, 5000, 10000, 30000)
var reconnectAttempts = 0

fun scheduleReconnect() {
    if (reconnectAttempts < RECONNECT_DELAYS.size) {
        val delay = RECONNECT_DELAYS[reconnectAttempts]
        Handler(Looper.getMainLooper()).postDelayed({
            reconnectAttempts++
            connectWebSocket()
        }, delay.toLong())
    } else {
        // æç¤ºç”¨æˆ·æ‰‹åŠ¨é‡è¿
        showError("è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–é‡æ–°æ¿€æ´»")
    }
}
```

---

## 5. APPé€šè®¯ä»£ç 

### 5.1 Kotlin å®Œæ•´å®ç°

#### 5.1.1 æ•°æ®æ¨¡å‹

```kotlin
// æ•°æ®ç±»å®šä¹‰
data class DeviceInfo(
    val deviceId: String,
    val model: String,
    val os: String,
    val osVersion: String,
    val manufacturer: String,
    val network: String,
    val appVersion: String,
    val totalMemory: Int,
    val screenResolution: String
)

data class VerifyRequest(
    val code: String,
    val deviceId: String
)

data class ActivateRequest(
    val code: String,
    val deviceInfo: DeviceInfo
)

data class ActivateResponse(
    val success: Boolean,
    val code: Int,
    val message: String,
    val data: ActivateData?
)

data class ActivateData(
    val robotId: String,
    val robotUuid: String,
    val token: String,
    val refreshToken: String,
    val expiresAt: String
)

data class HeartbeatRequest(
    val timestamp: Long,
    val memoryUsage: Long,
    val cpuUsage: Int,
    val batteryLevel: Int,
    val networkType: String
)

data class WSMessage(
    val type: String,
    val data: Map<String, Any>,
    val timestamp: Long = System.currentTimeMillis(),
    val messageId: String = UUID.randomUUID().toString()
)
```

#### 5.1.2 APIå®¢æˆ·ç«¯

```kotlin
import okhttp3.*
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.*
import com.google.gson.Gson

class ApiClient private constructor() {
    companion object {
        private const val BASE_URL = "https://your-server.com"
        
        @Volatile
        private var instance: ApiClient? = null
        
        fun getInstance() = instance ?: synchronized(this) {
            instance ?: ApiClient().also { instance = it }
        }
    }
    
    private val client = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .writeTimeout(30, TimeUnit.SECONDS)
        .build()
    
    private val retrofit = Retrofit.Builder()
        .baseUrl(BASE_URL)
        .client(client)
        .addConverterFactory(GsonConverterFactory.create())
        .build()
    
    private val apiService = retrofit.create(ApiService::class.java)
    private val gson = Gson()
    
    private var token: String? = null
    
    fun setToken(token: String) {
        this.token = token
    }
    
    suspend fun verifyCode(code: String): Result<VerifyData> {
        return try {
            val deviceId = getDeviceId()
            val request = VerifyRequest(code, deviceId)
            
            val response = apiService.verifyCode(request)
            
            if (response.success && response.data != null) {
                Result.success(response.data)
            } else {
                Result.failure(Exception(response.message))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun activateRobot(code: String): Result<ActivateData> {
        return try {
            val deviceInfo = DeviceInfo(
                deviceId = getDeviceId(),
                model = Build.MODEL,
                os = "Android",
                osVersion = Build.VERSION.RELEASE,
                manufacturer = Build.MANUFACTURER,
                network = getNetworkType(),
                appVersion = getAppVersion(),
                totalMemory = getTotalMemory(),
                screenResolution = getScreenResolution()
            )
            
            val request = ActivateRequest(code, deviceInfo)
            
            val response = apiService.activateRobot(request)
            
            if (response.success && response.data != null) {
                // ä¿å­˜é…ç½®
                saveConfig(response.data)
                
                // è®¾ç½®Token
                setToken(response.data.token)
                
                Result.success(response.data)
            } else {
                Result.failure(Exception(response.message))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun sendHeartbeat(): Result<String> {
        return try {
            val request = HeartbeatRequest(
                timestamp = System.currentTimeMillis(),
                memoryUsage = getMemoryUsage(),
                cpuUsage = getCpuUsage(),
                batteryLevel = getBatteryLevel(),
                networkType = getNetworkType()
            )
            
            val response = apiService.sendHeartbeat(token!!, request)
            
            if (response.success) {
                Result.success("OK")
            } else {
                Result.failure(Exception(response.message))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    // å·¥å…·æ–¹æ³•
    private fun getDeviceId(): String {
        return Settings.Secure.getString(
            context.contentResolver,
            Settings.Secure.ANDROID_ID
        ) ?: ""
    }
    
    private fun getNetworkType(): String {
        val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val networkInfo = cm.activeNetworkInfo
        return when (networkInfo?.type) {
            ConnectivityManager.TYPE_WIFI -> "wifi"
            ConnectivityManager.TYPE_MOBILE -> "mobile"
            else -> "unknown"
        }
    }
    
    private fun getBatteryLevel(): Int {
        val batteryStatus: Intent? = IntentFilter(Intent.ACTION_BATTERY_CHANGED).let { intent ->
            context.registerReceiver(null, intent)
        }
        val level: Int = batteryStatus?.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) ?: -1
        val scale: Int = batteryStatus?.getIntExtra(BatteryManager.EXTRA_SCALE, -1) ?: -1
        return if (level != -1 && scale != -1) {
            (level * 100) / scale
        } else {
            -1
        }
    }
    
    private fun getAppVersion(): String {
        return try {
            val packageInfo = context.packageManager.getPackageInfo(context.packageName, 0)
            packageInfo.versionName
        } catch (e: Exception) {
            "unknown"
        }
    }
    
    private fun getMemoryUsage(): Long {
        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val memoryInfo = ActivityManager.MemoryInfo()
        activityManager.getMemoryInfo(memoryInfo)
        return memoryInfo.availMem
    }
    
    private fun getCpuUsage(): Int {
        return try {
            val reader = RandomAccessFile("/proc/stat", "r")
            val load = reader.readLine()
            val toks = load.split(" ".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
            val idle1 = toks[5].toLong()
            val cpu1 = toks[2].toLong() + toks[3].toLong() + toks[4].toLong()
            Thread.sleep(360)
            reader.seek(0)
            val load2 = reader.readLine()
            reader.close()
            val toks2 = load2.split(" ".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
            val idle2 = toks2[5].toLong()
            val cpu2 = toks2[2].toLong() + toks2[3].toLong() + toks2[4].toLong()
            ((cpu2 - cpu1) * 100.0f / ((cpu2 + idle2) - (cpu1 + idle1))).toInt()
        } catch (ex: Exception) {
            0
        }
    }
    
    private fun getTotalMemory(): Int {
        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val memoryInfo = ActivityManager.MemoryInfo()
        activityManager.getMemoryInfo(memoryInfo)
        return (memoryInfo.totalMem / (1024 * 1024)).toInt()
    }
    
    private fun getScreenResolution(): String {
        val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
        val displayMetrics = DisplayMetrics()
        windowManager.defaultDisplay.getMetrics(displayMetrics)
        return "${displayMetrics.widthPixels}x${displayMetrics.heightPixels}"
    }
    
    private fun saveConfig(data: ActivateData) {
        val prefs = context.getSharedPreferences("robot_config", Context.MODE_PRIVATE)
        prefs.edit().apply {
            putString("robot_id", data.robotId)
            putString("robot_uuid", data.robotUuid)
            putString("token", data.token)
            putString("refresh_token", data.refreshToken)
            putLong("expires_at", SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US)
                .parse(data.expiresAt)?.time ?: 0)
            putLong("activated_at", System.currentTimeMillis())
            apply()
        }
    }
}

interface ApiService {
    @POST("/api/robot-ids/verify")
    suspend fun verifyCode(@Body request: VerifyRequest): VerifyResponse
    
    @POST("/api/robot-ids/activate")
    suspend fun activateRobot(@Body request: ActivateRequest): ActivateResponse
    
    @POST("/api/heartbeat")
    suspend fun sendHeartbeat(
        @Header("Authorization") token: String,
        @Body request: HeartbeatRequest
    ): HeartbeatResponse
}
```

#### 5.1.3 WebSocket å®¢æˆ·ç«¯

```kotlin
import okhttp3.*
import okio.ByteString
import java.util.*

class WebSocketClient(
    private val context: Context,
    private val robotId: String,
    private val token: String
) {
    private var ws: WebSocket? = null
    private val messageQueue = mutableListOf<WSMessage>()
    private var isConnected = false
    private val reconnectDelays = listOf(1000L, 2000L, 5000L, 10000L, 30000L)
    private var reconnectAttempts = 0
    
    private val client = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(0, TimeUnit.MILLISECONDS)
        .writeTimeout(0, TimeUnit.MILLISECONDS)
        .pingInterval(30, TimeUnit.SECONDS)
        .build()
    
    private val gson = Gson()
    
    fun connect() {
        val url = "wss://your-server.com/ws/connect?token=$token"
        
        val request = Request.Builder()
            .url(url)
            .build()
        
        ws = client.newWebSocket(request, object : WebSocketListener() {
            override fun onOpen(webSocket: WebSocket, response: Response) {
                isConnected = true
                reconnectAttempts = 0
                Log.d(TAG, "WebSocket connected")
                
                // å‘é€æ’é˜Ÿçš„æ¶ˆæ¯
                messageQueue.forEach { msg ->
                    webSocket.send(gson.toJson(msg))
                }
                messageQueue.clear()
                
                // å‘é€å¿ƒè·³
                startHeartbeat(webSocket)
            }
            
            override fun onMessage(webSocket: WebSocket, text: String) {
                Log.d(TAG, "Received: $text")
                val message = gson.fromJson(text, WSMessage::class.java)
                handleMessage(message)
            }
            
            override fun onMessage(webSocket: WebSocket, bytes: ByteString) {
                // å¤„ç†äºŒè¿›åˆ¶æ¶ˆæ¯
            }
            
            override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {
                Log.d(TAG, "Closing: $code $reason")
                isConnected = false
            }
            
            override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
                Log.d(TAG, "Closed: $code $reason")
                isConnected = false
                scheduleReconnect()
            }
            
            override fun onFailure(
                webSocket: WebSocket,
                t: Throwable,
                response: Response?
            ) {
                Log.e(TAG, "Error: ${t.message}", t)
                isConnected = false
                scheduleReconnect()
            }
        })
    }
    
    fun send(message: WSMessage) {
        if (isConnected && ws != null) {
            ws!!.send(gson.toJson(message))
        } else {
            Log.d(TAG, "Message queued: ${message.type}")
            messageQueue.add(message)
        }
    }
    
    fun disconnect() {
        ws?.close(1000, "Normal close")
        ws = null
        isConnected = false
    }
    
    private fun handleMessage(message: WSMessage) {
        when (message.type) {
            "command" -> handleCommand(message.data)
            "config" -> handleConfig(message.data)
            "heartbeat_response" -> handleHeartbeatResponse(message.data)
            "error" -> handleError(message.data)
            else -> Log.w(TAG, "Unknown message type: ${message.type}")
        }
    }
    
    private fun handleCommand(data: Map<String, Any>) {
        val commandId = data["commandId"] as String
        val commandType = data["commandType"] as String
        val params = data["params"] as Map<String, Any>
        
        Log.d(TAG, "Received command: $commandType")
        
        // æ‰§è¡ŒæŒ‡ä»¤
        CoroutineScope(Dispatchers.IO).launch {
            val result = executeCommand(commandType, params)
            
            // å‘é€ç»“æœ
            send(WSMessage(
                type = "result",
                data = mapOf(
                    "commandId" to commandId,
                    "status" to result.status,
                    "result" to result.data,
                    "errorMessage" to result.errorMessage
                )
            ))
        }
    }
    
    private fun executeCommand(commandType: String, params: Map<String, Any>): CommandResult {
        return try {
            when (commandType) {
                "send_message" -> {
                    val target = params["target"] as String
                    val content = params["content"] as String
                    val messageType = params["messageType"] as String
                    
                    // è°ƒç”¨ä¼ä¸šå¾®ä¿¡APIå‘é€æ¶ˆæ¯
                    val messageId = sendWeChatMessage(target, content, messageType)
                    
                    CommandResult(
                        status = "success",
                        data = mapOf("messageId" to messageId),
                        errorMessage = null
                    )
                }
                else -> CommandResult(
                    status = "failed",
                    data = null,
                    errorMessage = "Unknown command type"
                )
            }
        } catch (e: Exception) {
            CommandResult(
                status = "failed",
                data = null,
                errorMessage = e.message
            )
        }
    }
    
    private fun sendWeChatMessage(target: String, content: String, messageType: String): String {
        // è°ƒç”¨ä¼ä¸šå¾®ä¿¡API
        // è¿”å›æ¶ˆæ¯ID
        return "msg-${UUID.randomUUID()}"
    }
    
    private fun handleConfig(data: Map<String, Any>) {
        val configType = data["configType"] as String
        val config = data["config"] as Map<String, Any>
        
        Log.d(TAG, "Received config: $configType")
        
        // ä¿å­˜é…ç½®
        val prefs = context.getSharedPreferences("robot_config", Context.MODE_PRIVATE)
        prefs.edit().apply {
            putString("config_$configType", gson.toJson(config))
            apply()
        }
    }
    
    private fun handleHeartbeatResponse(data: Map<String, Any>) {
        val serverTime = data["serverTime"] as String
        Log.d(TAG, "Heartbeat response: $serverTime")
    }
    
    private fun handleError(data: Map<String, Any>) {
        val errorMessage = data["errorMessage"] as String
        Log.e(TAG, "Server error: $errorMessage")
        
        // æ˜¾ç¤ºé”™è¯¯
        showError(errorMessage)
    }
    
    private fun startHeartbeat(webSocket: WebSocket) {
        CoroutineScope(Dispatchers.IO).launch {
            while (isConnected) {
                delay(30000) // 30ç§’
                
                if (isConnected) {
                    val heartbeat = WSMessage(
                        type = "heartbeat",
                        data = mapOf(
                            "timestamp" to System.currentTimeMillis(),
                            "memoryUsage" to getMemoryUsage(),
                            "batteryLevel" to getBatteryLevel(),
                            "networkType" to getNetworkType()
                        )
                    )
                    webSocket.send(gson.toJson(heartbeat))
                }
            }
        }
    }
    
    private fun scheduleReconnect() {
        if (reconnectAttempts < reconnectDelays.size) {
            val delay = reconnectDelays[reconnectAttempts]
            Log.d(TAG, "Reconnecting in ${delay}ms...")
            
            Handler(Looper.getMainLooper()).postDelayed({
                reconnectAttempts++
                connect()
            }, delay)
        } else {
            Log.e(TAG, "Max reconnection attempts reached")
            showError("è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–é‡æ–°æ¿€æ´»")
        }
    }
    
    private fun showError(message: String) {
        // æ˜¾ç¤ºé”™è¯¯é€šçŸ¥
        Toast.makeText(context, message, Toast.LENGTH_LONG).show()
    }
    
    companion object {
        private const val TAG = "WebSocketClient"
    }
}

data class CommandResult(
    val status: String,
    val data: Map<String, Any>?,
    val errorMessage: String?
)
```

#### 5.1.4 ä½¿ç”¨ç¤ºä¾‹

```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var apiClient: ApiClient
    private lateinit var wsClient: WebSocketClient
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        apiClient = ApiClient.getInstance()
        
        // æ£€æŸ¥æ˜¯å¦å·²æ¿€æ´»
        val prefs = getSharedPreferences("robot_config", Context.MODE_PRIVATE)
        val robotId = prefs.getString("robot_id", null)
        val token = prefs.getString("token", null)
        
        if (robotId != null && token != null) {
            // å·²æ¿€æ´»ï¼Œè¿æ¥WebSocket
            wsClient = WebSocketClient(this, robotId, token)
            wsClient.connect()
        } else {
            // æœªæ¿€æ´»ï¼Œæ˜¾ç¤ºæ¿€æ´»ç•Œé¢
            showActivationScreen()
        }
    }
    
    private fun activateRobot(code: String) {
        lifecycleScope.launch {
            when (val result = apiClient.activateRobot(code)) {
                is Result.Success -> {
                    // æ¿€æ´»æˆåŠŸï¼Œè¿æ¥WebSocket
                    wsClient = WebSocketClient(
                        this@MainActivity,
                        result.data.robotId,
                        result.data.token
                    )
                    wsClient.connect()
                    
                    Toast.makeText(
                        this@MainActivity,
                        "æ¿€æ´»æˆåŠŸï¼",
                        Toast.LENGTH_SHORT
                    ).show()
                }
                is Result.Failure -> {
                    Toast.makeText(
                        this@MainActivity,
                        "æ¿€æ´»å¤±è´¥ï¼š${result.exception.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    }
    
    override fun onDestroy() {
        super.onDestroy()
        wsClient?.disconnect()
    }
}
```

### 5.2 Java å®Œæ•´å®ç°ï¼ˆå¤‡é€‰ï¼‰

#### 5.2.1 APIå®¢æˆ·ç«¯

```java
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;
import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;
import retrofit2.http.*;

public class ApiClient {
    private static final String BASE_URL = "https://your-server.com";
    private static ApiClient instance;
    
    private ApiService apiService;
    private String token;
    
    private ApiClient() {
        Retrofit retrofit = new Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build();
        
        apiService = retrofit.create(ApiService.class);
    }
    
    public static synchronized ApiClient getInstance() {
        if (instance == null) {
            instance = new ApiClient();
        }
        return instance;
    }
    
    public void setToken(String token) {
        this.token = token;
    }
    
    public void verifyCode(String code, Callback<VerifyResponse> callback) {
        String deviceId = getDeviceId();
        VerifyRequest request = new VerifyRequest(code, deviceId);
        apiService.verifyCode(request).enqueue(callback);
    }
    
    public void activateRobot(String code, Callback<ActivateResponse> callback) {
        DeviceInfo deviceInfo = new DeviceInfo(
            getDeviceId(),
            Build.MODEL,
            "Android",
            Build.VERSION.RELEASE,
            Build.MANUFACTURER,
            getNetworkType(),
            getAppVersion(),
            getTotalMemory(),
            getScreenResolution()
        );
        
        ActivateRequest request = new ActivateRequest(code, deviceInfo);
        apiService.activateRobot(request).enqueue(callback);
    }
    
    private String getDeviceId() {
        return Settings.Secure.getString(
            getContentResolver(),
            Settings.Secure.ANDROID_ID
        );
    }
    
    private String getNetworkType() {
        ConnectivityManager cm = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);
        NetworkInfo networkInfo = cm.getActiveNetworkInfo();
        if (networkInfo != null && networkInfo.isConnected()) {
            if (networkInfo.getType() == ConnectivityManager.TYPE_WIFI) {
                return "wifi";
            } else if (networkInfo.getType() == ConnectivityManager.TYPE_MOBILE) {
                return "mobile";
            }
        }
        return "unknown";
    }
    
    private String getAppVersion() {
        try {
            PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(), 0);
            return packageInfo.versionName;
        } catch (Exception e) {
            return "unknown";
        }
    }
    
    private int getTotalMemory() {
        ActivityManager activityManager = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
        ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();
        activityManager.getMemoryInfo(memoryInfo);
        return (int) (memoryInfo.totalMem / (1024 * 1024));
    }
    
    private String getScreenResolution() {
        WindowManager windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);
        DisplayMetrics displayMetrics = new DisplayMetrics();
        windowManager.getDefaultDisplay().getMetrics(displayMetrics);
        return displayMetrics.widthPixels + "x" + displayMetrics.heightPixels;
    }
}

interface ApiService {
    @POST("/api/robot-ids/verify")
    Call<VerifyResponse> verifyCode(@Body VerifyRequest request);
    
    @POST("/api/robot-ids/activate")
    Call<ActivateResponse> activateRobot(@Body ActivateRequest request);
}
```

#### 5.2.2 WebSocket å®¢æˆ·ç«¯

```java
import okhttp3.*;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

public class WebSocketClient {
    private static final String TAG = "WebSocketClient";
    private static final long[] RECONNECT_DELAYS = {1000, 2000, 5000, 10000, 30000};
    
    private OkHttpClient client;
    private WebSocket webSocket;
    private String robotId;
    private String token;
    private boolean isConnected = false;
    private int reconnectAttempts = 0;
    
    public WebSocketClient(Context context, String robotId, String token) {
        this.robotId = robotId;
        this.token = token;
        
        client = new OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(0, TimeUnit.MILLISECONDS)
            .writeTimeout(0, TimeUnit.MILLISECONDS)
            .pingInterval(30, TimeUnit.SECONDS)
            .build();
    }
    
    public void connect() {
        String url = "wss://your-server.com/ws/connect?token=" + token;
        Request request = new Request.Builder()
            .url(url)
            .build();
        
        webSocket = client.newWebSocket(request, new WebSocketListener() {
            @Override
            public void onOpen(WebSocket webSocket, Response response) {
                isConnected = true;
                reconnectAttempts = 0;
                Log.d(TAG, "WebSocket connected");
                
                // å¼€å§‹å‘é€å¿ƒè·³
                startHeartbeat(webSocket);
            }
            
            @Override
            public void onMessage(WebSocket webSocket, String text) {
                Log.d(TAG, "Received: " + text);
                handleMessage(text);
            }
            
            @Override
            public void onClosing(WebSocket webSocket, int code, String reason) {
                Log.d(TAG, "Closing: " + code + " " + reason);
                isConnected = false;
            }
            
            @Override
            public void onClosed(WebSocket webSocket, int code, String reason) {
                Log.d(TAG, "Closed: " + code + " " + reason);
                isConnected = false;
                scheduleReconnect();
            }
            
            @Override
            public void onFailure(WebSocket webSocket, Throwable t, Response response) {
                Log.e(TAG, "Error: " + t.getMessage(), t);
                isConnected = false;
                scheduleReconnect();
            }
        });
    }
    
    public void send(String message) {
        if (isConnected && webSocket != null) {
            webSocket.send(message);
        }
    }
    
    public void disconnect() {
        if (webSocket != null) {
            webSocket.close(1000, "Normal close");
            webSocket = null;
        }
        isConnected = false;
    }
    
    private void handleMessage(String text) {
        try {
            JSONObject json = new JSONObject(text);
            String type = json.getString("type");
            
            switch (type) {
                case "command":
                    handleCommand(json.getJSONObject("data"));
                    break;
                case "config":
                    handleConfig(json.getJSONObject("data"));
                    break;
                case "heartbeat_response":
                    handleHeartbeatResponse(json.getJSONObject("data"));
                    break;
                default:
                    Log.w(TAG, "Unknown message type: " + type);
            }
        } catch (Exception e) {
            Log.e(TAG, "Error handling message: " + e.getMessage(), e);
        }
    }
    
    private void handleCommand(JSONObject data) throws JSONException {
        String commandId = data.getString("commandId");
        String commandType = data.getString("commandType");
        JSONObject params = data.getJSONObject("params");
        
        Log.d(TAG, "Received command: " + commandType);
        
        // æ‰§è¡ŒæŒ‡ä»¤
        CommandResult result = executeCommand(commandType, params);
        
        // å‘é€ç»“æœ
        JSONObject resultJson = new JSONObject();
        resultJson.put("type", "result");
        resultJson.put("data", new JSONObject()
            .put("commandId", commandId)
            .put("status", result.status)
            .put("result", result.data != null ? new JSONObject(result.data) : null)
            .put("errorMessage", result.errorMessage));
        
        send(resultJson.toString());
    }
    
    private CommandResult executeCommand(String commandType, JSONObject params) {
        try {
            if ("send_message".equals(commandType)) {
                String target = params.getString("target");
                String content = params.getString("content");
                String messageType = params.getString("messageType");
                
                // è°ƒç”¨ä¼ä¸šå¾®ä¿¡API
                String messageId = sendWeChatMessage(target, content, messageType);
                
                return new CommandResult("success", 
                    Map.of("messageId", messageId), null);
            } else {
                return new CommandResult("failed", null, "Unknown command type");
            }
        } catch (Exception e) {
            return new CommandResult("failed", null, e.getMessage());
        }
    }
    
    private String sendWeChatMessage(String target, String content, String messageType) {
        // è°ƒç”¨ä¼ä¸šå¾®ä¿¡API
        return "msg-" + UUID.randomUUID().toString();
    }
    
    private void handleConfig(JSONObject data) throws JSONException {
        String configType = data.getString("configType");
        JSONObject config = data.getJSONObject("config");
        
        Log.d(TAG, "Received config: " + configType);
        
        // ä¿å­˜é…ç½®
        SharedPreferences prefs = context.getSharedPreferences(
            "robot_config", Context.MODE_PRIVATE);
        SharedPreferences.Editor editor = prefs.edit();
        editor.putString("config_" + configType, config.toString());
        editor.apply();
    }
    
    private void handleHeartbeatResponse(JSONObject data) throws JSONException {
        String serverTime = data.getString("serverTime");
        Log.d(TAG, "Heartbeat response: " + serverTime);
    }
    
    private void startHeartbeat(WebSocket ws) {
        new Thread(() -> {
            while (isConnected) {
                try {
                    Thread.sleep(30000); // 30ç§’
                    
                    if (isConnected) {
                        JSONObject heartbeat = new JSONObject();
                        heartbeat.put("type", "heartbeat");
                        heartbeat.put("data", new JSONObject()
                            .put("timestamp", System.currentTimeMillis())
                            .put("memoryUsage", getMemoryUsage())
                            .put("batteryLevel", getBatteryLevel())
                            .put("networkType", getNetworkType()));
                        
                        ws.send(heartbeat.toString());
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Heartbeat error: " + e.getMessage(), e);
                }
            }
        }).start();
    }
    
    private void scheduleReconnect() {
        if (reconnectAttempts < RECONNECT_DELAYS.length) {
            long delay = RECONNECT_DELAYS[reconnectAttempts];
            Log.d(TAG, "Reconnecting in " + delay + "ms...");
            
            new Handler(Looper.getMainLooper()).postDelayed(() -> {
                reconnectAttempts++;
                connect();
            }, delay);
        } else {
            Log.e(TAG, "Max reconnection attempts reached");
        }
    }
    
    private int getMemoryUsage() {
        ActivityManager activityManager = (ActivityManager) context.getSystemService(ACTIVITY_SERVICE);
        ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();
        activityManager.getMemoryInfo(memoryInfo);
        return (int) (memoryInfo.availMem / (1024 * 1024));
    }
    
    private int getBatteryLevel() {
        IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
        Intent batteryStatus = context.registerReceiver(null, ifilter);
        int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
        int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
        return level * 100 / scale;
    }
    
    private String getNetworkType() {
        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(CONNECTIVITY_SERVICE);
        NetworkInfo networkInfo = cm.getActiveNetworkInfo();
        if (networkInfo != null && networkInfo.isConnected()) {
            if (networkInfo.getType() == ConnectivityManager.TYPE_WIFI) {
                return "wifi";
            } else if (networkInfo.getType() == ConnectivityManager.TYPE_MOBILE) {
                return "mobile";
            }
        }
        return "unknown";
    }
    
    static class CommandResult {
        String status;
        Map<String, Object> data;
        String errorMessage;
        
        CommandResult(String status, Map<String, Object> data, String errorMessage) {
            this.status = status;
            this.data = data;
            this.errorMessage = errorMessage;
        }
    }
}
```

---

## 6. ç¬¬ä¸‰æ–¹å¹³å°é€šè®¯åè®®

### 6.1 é›†æˆæ–¹å¼

WorkBot æ”¯æŒä¸¤ç§ç¬¬ä¸‰æ–¹é›†æˆæ–¹å¼ï¼š

| æ–¹å¼ | åè®® | ç”¨é€” | å®ç°éš¾åº¦ |
|-----|------|------|---------|
| **HTTP å›è°ƒ** | HTTP POST | æ¨é€æ¶ˆæ¯å’Œç»“æœ | ç®€å• |
| **WebSocket ä»£ç†** | WebSocket | å®æ—¶åŒå‘é€šè®¯ | ä¸­ç­‰ |

### 6.2 HTTP å›è°ƒåè®®

#### 6.2.1 å›è°ƒç±»å‹

| å›è°ƒç±»å‹ | è¯´æ˜ | è§¦å‘æ—¶æœº |
|---------|------|---------|
| **message** | æ¶ˆæ¯å›è°ƒ | æ”¶åˆ°æ–°æ¶ˆæ¯æ—¶ |
| **result** | ç»“æœå›è°ƒ | æŒ‡ä»¤æ‰§è¡Œå®Œæˆæ—¶ |
| **qrcode** | äºŒç»´ç å›è°ƒ | è·å–ç¾¤äºŒç»´ç æ—¶ |
| **online** | ä¸Šçº¿å›è°ƒ | æœºå™¨äººä¸Šçº¿æ—¶ |
| **offline** | ä¸‹çº¿å›è°ƒ | æœºå™¨äººä¸‹çº¿æ—¶ |
| **image** | å›¾ç‰‡å›è°ƒ | æ”¶åˆ°å›¾ç‰‡æ¶ˆæ¯æ—¶ |

#### 6.2.2 å›è°ƒåœ°å€é…ç½®

**åŸºç¡€URL**ï¼š`https://third-party.com`

**å®Œæ•´å›è°ƒåœ°å€**ï¼š
```
æ¶ˆæ¯å›è°ƒ:
  https://third-party.com/api/callback/message?robotId=RBml9n7nikHIMZU0

ç»“æœå›è°ƒ:
  https://third-party.com/api/callback/result?robotId=RBml9n7nikHIMZU0

äºŒç»´ç å›è°ƒ:
  https://third-party.com/api/callback/qrcode?robotId=RBml9n7nikHIMZU0

ä¸Šçº¿å›è°ƒ:
  https://third-party.com/api/callback/online?robotId=RBml9n7nikHIMZU0

ä¸‹çº¿å›è°ƒ:
  https://third-party.com/api/callback/offline?robotId=RBml9n7nikHIMZU0

å›¾ç‰‡å›è°ƒ:
  https://third-party.com/api/callback/image?robotId=RBml9n7nikHIMZU0
```

#### 6.2.3 æ¶ˆæ¯å›è°ƒ

**æ¥å£**ï¼š`POST /api/callback/message?robotId={robotId}`

**è¯·æ±‚å¤´**ï¼š
```http
Content-Type: application/json
X-Robot-Id: {robotId}
X-Timestamp: {timestamp}
X-Signature: {signature}
```

**è¯·æ±‚ä½“**ï¼š
```json
{
  "messageId": "msg-1770341503000-abc123",
  "senderId": "wxid-xxx",
  "senderName": "å¼ ä¸‰",
  "messageType": "text",
  "content": "ä½ å¥½ï¼Œåœ¨å—ï¼Ÿ",
  "chatType": "single",
  "extraData": null,
  "timestamp": "2026-02-06T10:05:03.000Z"
}
```

**å­—æ®µè¯´æ˜**ï¼š

| å­—æ®µ | ç±»å‹ | è¯´æ˜ |
|-----|------|------|
| messageId | string | æ¶ˆæ¯ID |
| senderId | string | å‘é€è€…ID |
| senderName | string | å‘é€è€…åç§° |
| messageType | string | æ¶ˆæ¯ç±»å‹ (text/image/video/audio/file/card) |
| content | string | æ¶ˆæ¯å†…å®¹ |
| chatType | string | èŠå¤©ç±»å‹ (single/group) |
| extraData | object | é¢å¤–æ•°æ® |
| timestamp | string | æ—¶é—´æˆ³ (ISO 8601) |

**å“åº”**ï¼š
```json
{
  "code": 200,
  "message": "æ¶ˆæ¯æ¥æ”¶æˆåŠŸ",
  "data": {
    "messageId": "msg-1770341503000-abc123",
    "robotId": "RBml9n7nikHIMZU0",
    "receivedAt": "2026-02-06T10:05:03.000Z"
  }
}
```

**ç¬¬ä¸‰æ–¹æœåŠ¡ç«¯å®ç°ç¤ºä¾‹**ï¼š

```typescript
import express from 'express';
import crypto from 'crypto';

const app = express();
app.use(express.json());

const SECRET_KEY = 'your-secret-key';

// éªŒè¯ç­¾å
function verifySignature(robotId: string, body: any, timestamp: string, signature: string): boolean {
  const payload = `${robotId}:${JSON.stringify(body)}:${timestamp}`;
  const expectedSignature = crypto
    .createHmac('sha256', SECRET_KEY)
    .update(payload)
    .digest('hex');
  
  return signature === expectedSignature;
}

// æ¶ˆæ¯å›è°ƒ
app.post('/api/callback/message', async (req, res) => {
  try {
    const robotId = req.query.robotId as string;
    const timestamp = req.headers['x-timestamp'] as string;
    const signature = req.headers['x-signature'] as string;
    
    // éªŒè¯ç­¾å
    if (!verifySignature(robotId, req.body, timestamp, signature)) {
      return res.status(401).json({
        code: 401,
        message: 'ç­¾åéªŒè¯å¤±è´¥'
      });
    }
    
    const { messageId, senderId, senderName, messageType, content, chatType } = req.body;
    
    console.log(`æ”¶åˆ°æ¶ˆæ¯ [${robotId}]: ${senderName}: ${content}`);
    
    // å¤„ç†æ¶ˆæ¯
    // ...
    
    return res.json({
      code: 200,
      message: 'æ¶ˆæ¯æ¥æ”¶æˆåŠŸ',
      data: {
        messageId,
        robotId,
        receivedAt: new Date().toISOString()
      }
    });
  } catch (error) {
    console.error('å¤„ç†æ¶ˆæ¯å›è°ƒå¤±è´¥:', error);
    return res.status(500).json({
      code: 500,
      message: 'å¤„ç†å¤±è´¥'
    });
  }
});

app.listen(3000, () => {
  console.log('ç¬¬ä¸‰æ–¹å›è°ƒæœåŠ¡å¯åŠ¨åœ¨ç«¯å£ 3000');
});
```

#### 6.2.4 ç»“æœå›è°ƒ

**æ¥å£**ï¼š`POST /api/callback/result?robotId={robotId}`

**è¯·æ±‚ä½“**ï¼š
```json
{
  "commandId": "cmd-1770341503000-abc123",
  "commandType": "send_message",
  "status": "success",
  "result": {
    "message": "æ‰§è¡ŒæˆåŠŸ",
    "messageId": "msg-002"
  },
  "errorMessage": null,
  "executedAt": "2026-02-06T10:05:05.000Z"
}
```

**å“åº”**ï¼š
```json
{
  "code": 200,
  "message": "æ‰§è¡Œç»“æœæ¥æ”¶æˆåŠŸ",
  "data": {
    "commandId": "cmd-1770341503000-abc123",
    "status": "success",
    "updatedAt": "2026-02-06T10:05:05.000Z"
  }
}
```

#### 6.2.5 äºŒç»´ç å›è°ƒ

**æ¥å£**ï¼š`POST /api/callback/qrcode?robotId={robotId}`

**è¯·æ±‚ä½“**ï¼š
```json
{
  "groupChatId": "group-xxx",
  "qrcodeUrl": "https://example.com/qrcode/xxx.png",
  "groupName": "æµ‹è¯•ç¾¤",
  "timestamp": "2026-02-06T10:05:00.000Z"
}
```

**å“åº”**ï¼š
```json
{
  "code": 200,
  "message": "ç¾¤äºŒç»´ç æ¥æ”¶æˆåŠŸ",
  "data": {
    "robotId": "RBml9n7nikHIMZU0",
    "groupChatId": "group-xxx",
    "qrcodeUrl": "https://example.com/qrcode/xxx.png",
    "receivedAt": "2026-02-06T10:05:00.000Z"
  }
}
```

#### 6.2.6 çŠ¶æ€å›è°ƒ

**æ¥å£**ï¼š`POST /api/callback/status?robotId={robotId}`

**è¯·æ±‚ä½“**ï¼š
```json
{
  "status": "online",
  "deviceInfo": {
    "model": "Xiaomi 14",
    "os": "Android 14",
    "appVersion": "1.0.0"
  },
  "timestamp": "2026-02-06T10:05:00.000Z"
}
```

**å“åº”**ï¼š
```json
{
  "code": 200,
  "message": "æœºå™¨äººçŠ¶æ€æ›´æ–°æˆåŠŸ",
  "data": {
    "robotId": "RBml9n7nikHIMZU0",
    "status": "online",
    "updatedAt": "2026-02-06T10:05:00.000Z"
  }
}
```

#### 6.2.7 å›¾ç‰‡å›è°ƒ

**æ¥å£**ï¼š`POST /api/callback/image?robotId={robotId}`

**è¯·æ±‚ä½“**ï¼š
```json
{
  "messageId": "msg-1770341503000-abc123",
  "senderId": "wxid-xxx",
  "senderName": "å¼ ä¸‰",
  "imageUrl": "https://example.com/image.png",
  "imageBase64": "base64_encoded_image_data",
  "timestamp": "2026-02-06T10:05:00.000Z"
}
```

**å“åº”**ï¼š
```json
{
  "code": 200,
  "message": "å›¾ç‰‡æ¶ˆæ¯æ¥æ”¶æˆåŠŸ",
  "data": {
    "messageId": "msg-1770341503000-abc123",
    "robotId": "RBml9n7nikHIMZU0",
    "imageUrl": "https://example.com/image.png",
    "receivedAt": "2026-02-06T10:05:00.000Z"
  }
}
```

### 6.3 WorkTool å¹³å°å…¼å®¹

#### 6.3.1 WorkTool API åœ°å€

```
åŸºç¡€URL: https://api.worktool.ymdyes.cn
```

#### 6.3.2 WorkTool æ¶ˆæ¯ç±»å‹

| type | è¯´æ˜ | å‚æ•° |
|-----|------|------|
| 203 | å‘é€æ–‡æœ¬æ¶ˆæ¯ | titleList, receivedContent, atList |
| 205 | è½¬å‘æ¶ˆæ¯ | sourceMessageId, targetList |
| 206 | ä¿®æ”¹ç¾¤ä¿¡æ¯ | groupName, newGroupName, groupNotice |
| 207 | ç¾¤ç®¡ç† | groupName, operation, memberList |
| 208 | æ”¹ç¾¤å¤‡æ³¨ | groupName, groupRemark |
| 209 | æ”¹ç¾¤å…¬å‘Š | groupName, groupNotice |
| 213 | ä¿®æ”¹ç¾¤æ¨¡æ¿ | groupName, groupTemplate |
| 218 | å‘é€æ–‡ä»¶ | titleList, objectName, fileUrl, fileType |
| 219 | è§£æ•£ç¾¤ | groupName |
| 220 | ä¿®æ”¹ç”¨æˆ·å¤‡æ³¨ | userName, userRemark |
| 221 | æ‹‰äººå…¥ç¾¤ | groupName, memberList |
| 225 | æŸ¥æ‰¾èŠå¤©çª— | keyword |
| 226 | é€€å‡ºç¾¤ | groupName |
| 234 | æŸ¥æ‰¾æ”¶è— | keyword, time |
| 304 | å‘é€å°ç¨‹åº | titleList, appName, userName, path |
| 305 | å‘é€åç‰‡ | titleList, nameCard |
| 512 | è·å–ç¾¤äºŒç»´ç  | groupName |
| 900 | å‘é€æ”¶è—æ¶ˆæ¯ | targetChat, locatorType, index/keyword/time |

#### 6.3.3 WorkTool API è°ƒç”¨ç¤ºä¾‹

**å‘é€æ–‡æœ¬æ¶ˆæ¯ (type=203)**ï¼š

```typescript
import axios from 'axios';

async function sendTextMessage(robotId: string, params: {
  titleList: string[];
  receivedContent: string;
  atList?: string[];
}) {
  const response = await axios.post('https://api.worktool.ymdyes.cn/api/v3/command', {
    robotId,
    type: 203,
    ...params
  });
  
  return response.data;
}

// ä½¿ç”¨ç¤ºä¾‹
await sendTextMessage('RBml9n7nikHIMZU0', {
  titleList: ['å¼ ä¸‰'],
  receivedContent: 'ä½ å¥½ï¼\nè¿™æ˜¯ä¸€æ¡æµ‹è¯•æ¶ˆæ¯',
  atList: ['@æ‰€æœ‰äºº']
});
```

**å‘é€æ–‡ä»¶æ¶ˆæ¯ (type=218)**ï¼š

```typescript
async function sendFileMessage(robotId: string, params: {
  titleList: string[];
  objectName: string;
  fileUrl: string;
  fileType: string;
  extraText?: string;
}) {
  const response = await axios.post('https://api.worktool.ymdyes.cn/api/v3/command', {
    robotId,
    type: 218,
    ...params
  });
  
  return response.data;
}

// ä½¿ç”¨ç¤ºä¾‹
await sendFileMessage('RBml9n7nikHIMZU0', {
  titleList: ['å¼ ä¸‰'],
  objectName: 'document.pdf',
  fileUrl: 'https://example.com/document.pdf',
  fileType: 'file',
  extraText: 'è¿™æ˜¯é‡è¦çš„æ–‡æ¡£ï¼Œè¯·æŸ¥æ”¶'
});
```

**è·å–ç¾¤äºŒç»´ç  (type=512)**ï¼š

```typescript
async function getGroupQRCode(robotId: string, groupName: string) {
  const response = await axios.post('https://api.worktool.ymdyes.cn/api/v3/command', {
    robotId,
    type: 512,
    groupName
  });
  
  return response.data;
}

// ä½¿ç”¨ç¤ºä¾‹
await getGroupQRCode('RBml9n7nikHIMZU0', 'æµ‹è¯•ç¾¤');
```

**å‘é€æ”¶è—æ¶ˆæ¯ (type=900)**ï¼š

```typescript
enum LocatorType {
  INDEX = 'index',      // é€šè¿‡ç´¢å¼•å®šä½
  KEYWORD = 'keyword',  // é€šè¿‡å…³é”®è¯å®šä½
  TIME = 'time'         // é€šè¿‡æ—¶é—´å®šä½
}

async function sendFavoriteMessage(robotId: string, params: {
  targetChat: string;
  locatorType: LocatorType;
  index?: number;
  keyword?: string;
  time?: string;
}) {
  const response = await axios.post('https://api.worktool.ymdyes.cn/api/v3/command', {
    robotId,
    type: 900,
    ...params
  });
  
  return response.data;
}

// ä½¿ç”¨ç¤ºä¾‹ - é€šè¿‡ç´¢å¼•å®šä½
await sendFavoriteMessage('RBml9n7nikHIMZU0', {
  targetChat: 'å·¥ä½œç¾¤',
  locatorType: LocatorType.INDEX,
  index: 0
});

// ä½¿ç”¨ç¤ºä¾‹ - é€šè¿‡å…³é”®è¯å®šä½
await sendFavoriteMessage('RBml9n7nikHIMZU0', {
  targetChat: 'å·¥ä½œç¾¤',
  locatorType: LocatorType.KEYWORD,
  keyword: 'é‡è¦æ–‡æ¡£'
});
```

### 6.4 ç¬¬ä¸‰æ–¹è°ƒç”¨ WorkBot

#### 6.4.1 å‘é€æŒ‡ä»¤

**æ¥å£**ï¼š`POST /api/commands`

**è¯·æ±‚å¤´**ï¼š
```http
Authorization: Bearer {token}
Content-Type: application/json
```

**è¯·æ±‚ä½“**ï¼š
```json
{
  "robotId": "RBml9n7nikHIMZU0",
  "commandType": "send_message",
  "params": {
    "target": "å¼ ä¸‰",
    "content": "ä½ å¥½ï¼",
    "messageType": "text"
  }
}
```

**å“åº”**ï¼š
```json
{
  "success": true,
  "code": 0,
  "data": {
    "commandId": "cmd-001",
    "status": "pending",
    "createdAt": "2026-02-06T10:00:00.000Z"
  }
}
```

#### 6.4.2 æŸ¥è¯¢æŒ‡ä»¤çŠ¶æ€

**æ¥å£**ï¼š`GET /api/commands/{commandId}`

**è¯·æ±‚å¤´**ï¼š
```http
Authorization: Bearer {token}
```

**å“åº”**ï¼š
```json
{
  "success": true,
  "code": 0,
  "data": {
    "commandId": "cmd-001",
    "robotId": "RBml9n7nikHIMZU0",
    "commandType": "send_message",
    "status": "success",
    "result": {
      "messageId": "msg-002"
    },
    "createdAt": "2026-02-06T10:00:00.000Z",
    "executedAt": "2026-02-06T10:00:05.000Z"
  }
}
```

---

## 7. é€šè®¯åœ°å€

### 7.1 WorkBot æœåŠ¡å™¨åœ°å€

| æœåŠ¡ | åè®® | åœ°å€ | ç«¯å£ | ç”¨é€” |
|-----|------|------|------|------|
| **API æœåŠ¡** | HTTPS | `https://your-workbot.com` | 5000 | HTTP API è°ƒç”¨ |
| **WebSocket æœåŠ¡** | WSS | `wss://your-workbot.com` | 5001 | åŒå‘å®æ—¶é€šè®¯ |

### 7.2 APP è¿æ¥åœ°å€

| ç”¨é€” | åè®® | åœ°å€ | è¯´æ˜ |
|-----|------|------|------|
| **æ¿€æ´»éªŒè¯** | HTTPS | `https://your-workbot.com/api/robot-ids/verify` | éªŒè¯æ¿€æ´»ç  |
| **æ¿€æ´»è®¾å¤‡** | HTTPS | `https://your-workbot.com/api/robot-ids/activate` | æ¿€æ´»æœºå™¨äºº |
| **å‘é€å¿ƒè·³** | HTTPS | `https://your-workbot.com/api/heartbeat` | ä¿æŒè¿æ¥ |
| **ä¸ŠæŠ¥ç»“æœ** | HTTPS | `https://your-workbot.com/api/result` | ä¸ŠæŠ¥æ‰§è¡Œç»“æœ |
| **WebSocket è¿æ¥** | WSS | `wss://your-workbot.com/ws/connect?token={token}` | å®æ—¶é€šè®¯ |

### 7.3 WorkBot æä¾›ç»™ç¬¬ä¸‰æ–¹çš„åœ°å€

**åŸºç¡€URL**ï¼š`https://your-workbot.com`

| åŠŸèƒ½ | åœ°å€ | è¯´æ˜ |
|-----|------|------|
| **å‘é€æŒ‡ä»¤** | `POST /api/commands` | ç¬¬ä¸‰æ–¹å‘WorkBotå‘é€æŒ‡ä»¤ |
| **æŸ¥è¯¢æŒ‡ä»¤çŠ¶æ€** | `GET /api/commands/{commandId}` | æŸ¥è¯¢æŒ‡ä»¤æ‰§è¡ŒçŠ¶æ€ |
| **è·å–æœºå™¨äººçŠ¶æ€** | `GET /api/robots/{robotId}/status` | è·å–æœºå™¨äººåœ¨çº¿çŠ¶æ€ |

### 7.4 ç¬¬ä¸‰æ–¹éœ€è¦æä¾›ç»™ WorkBot çš„åœ°å€

**åŸºç¡€URL**ï¼š`https://third-party.com`

| åŠŸèƒ½ | åœ°å€ | è¯´æ˜ |
|-----|------|------|
| **æ¶ˆæ¯å›è°ƒ** | `POST /api/callback/message?robotId={robotId}` | WorkBotæ¨é€æ¶ˆæ¯åˆ°ç¬¬ä¸‰æ–¹ |
| **ç»“æœå›è°ƒ** | `POST /api/callback/result?robotId={robotId}` | WorkBotæ¨é€æ‰§è¡Œç»“æœåˆ°ç¬¬ä¸‰æ–¹ |
| **äºŒç»´ç å›è°ƒ** | `POST /api/callback/qrcode?robotId={robotId}` | WorkBotæ¨é€ç¾¤äºŒç»´ç åˆ°ç¬¬ä¸‰æ–¹ |
| **ä¸Šçº¿å›è°ƒ** | `POST /api/callback/online?robotId={robotId}` | WorkBotæ¨é€ä¸Šçº¿é€šçŸ¥åˆ°ç¬¬ä¸‰æ–¹ |
| **ä¸‹çº¿å›è°ƒ** | `POST /api/callback/offline?robotId={robotId}` | WorkBotæ¨é€ä¸‹çº¿é€šçŸ¥åˆ°ç¬¬ä¸‰æ–¹ |
| **å›¾ç‰‡å›è°ƒ** | `POST /api/callback/image?robotId={robotId}` | WorkBotæ¨é€å›¾ç‰‡æ¶ˆæ¯åˆ°ç¬¬ä¸‰æ–¹ |

### 7.5 WorkTool å¹³å°åœ°å€

| æœåŠ¡ | åœ°å€ | è¯´æ˜ |
|-----|------|------|
| **WorkTool API** | `https://api.worktool.ymdyes.cn` | WorkToolå®˜æ–¹API |

---

## é™„å½•

### A. é”™è¯¯ç 

| é”™è¯¯ç  | è¯´æ˜ | å¤„ç†æ–¹å¼ |
|-------|------|---------|
| 0 | æˆåŠŸ | - |
| 400 | è¯·æ±‚å‚æ•°é”™è¯¯ | æ£€æŸ¥å‚æ•°æ ¼å¼ |
| 401 | æœªæˆæƒ | æ£€æŸ¥Token |
| 403 | ç¦æ­¢è®¿é—® | æ£€æŸ¥æƒé™ |
| 404 | èµ„æºä¸å­˜åœ¨ | æ£€æŸ¥èµ„æºID |
| 500 | æœåŠ¡å™¨é”™è¯¯ | è”ç³»ç®¡ç†å‘˜ |

### B. ç­¾åéªŒè¯

**ç­¾åç”Ÿæˆç®—æ³•**ï¼š

```
signature = HMAC-SHA256(SECRET_KEY, robotId + body + timestamp)
```

**å®ç°ç¤ºä¾‹**ï¼š

```typescript
import crypto from 'crypto';

function generateSignature(
  robotId: string,
  body: any,
  timestamp: string,
  secretKey: string
): string {
  const payload = `${robotId}:${JSON.stringify(body)}:${timestamp}`;
  return crypto
    .createHmac('sha256', secretKey)
    .update(payload)
    .digest('hex');
}
```

### C. å¸¸è§é—®é¢˜

#### Q1: WebSocket è¿æ¥æ–­å¼€åå¦‚ä½•é‡è¿ï¼Ÿ

ä½¿ç”¨æŒ‡æ•°é€€é¿ç­–ç•¥ï¼š
1. ç¬¬1æ¬¡ï¼š1ç§’åé‡è¿
2. ç¬¬2æ¬¡ï¼š2ç§’åé‡è¿
3. ç¬¬3æ¬¡ï¼š5ç§’åé‡è¿
4. ç¬¬4æ¬¡ï¼š10ç§’åé‡è¿
5. ç¬¬5æ¬¡ï¼š30ç§’åé‡è¿
6. è¶…è¿‡5æ¬¡ï¼šæç¤ºç”¨æˆ·æ‰‹åŠ¨é‡è¿

#### Q2: æ¿€æ´»ç å¯ä»¥é‡å¤ä½¿ç”¨å—ï¼Ÿ

- **æœªä½¿ç”¨çš„æ¿€æ´»ç **ï¼šå¯ä»¥æ¿€æ´»ï¼Œæ¿€æ´»åç»‘å®šåˆ°è®¾å¤‡
- **å·²ä½¿ç”¨çš„æ¿€æ´»ç **ï¼š
  - ç»‘å®šåˆ°å½“å‰è®¾å¤‡ï¼šå¯ä»¥é‡æ–°æ¿€æ´»
  - ç»‘å®šåˆ°å…¶ä»–è®¾å¤‡ï¼šæ— æ³•æ¿€æ´»

#### Q3: Token è¿‡æœŸåå¦‚ä½•å¤„ç†ï¼Ÿ

- **Access Token è¿‡æœŸ**ï¼šä½¿ç”¨ Refresh Token åˆ·æ–°
- **Refresh Token è¿‡æœŸ**ï¼šéœ€è¦é‡æ–°æ¿€æ´»

---

**æ–‡æ¡£ç»“æŸ**

**ç‰ˆæœ¬**ï¼šv4.0
**æ›´æ–°æ—¥æœŸ**ï¼š2026-02-06
**ç»´æŠ¤è€…**ï¼šWorkBot Team
